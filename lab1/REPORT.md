# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Шатунова Ю. В., группа М8О-208Б-20

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   21.10      |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных тем, что эти списки представляют собой либо пустой элемент, либо один элемент, который называется головой, и присоединенную к нему часть, называемую хвостом. Список в Прологе представляет собой рекурсивную структуру данных. А в императивных языках мы можем использовать итераторы.
Списки в Прологе, если сравнивать с традиционными языками, больше напоминают массивы.

## Задание 1.1: Предикат обработки списка

Стандартные предикаты для работы со списками указаны ниже.

```prolog
%  Длина списка
%  (список, длина)
my_length([], 0).
my_length([_|L], N) :- my_length(L, M), N is M + 1.

%  Принадлежность элемента списку
%  (элемент, список)
my_member(X, [X|_]).
my_member(X, [_|T]) :- my_member(X, T).

%  Конкатeнация списков
%  (список1, список2, список1+2)
my_append([], L, L).
my_append([X|L1], L2, [X|L3]) :- my_append(L1, L2, L3).

%  Удаление элемента из списка
%  (элемент, список, список без элемента)
my_remove(X, [X|T], T).
my_remove(X, [Y|T], [Y|Z]) :- my_remove(X, T, Z).

%  Перестановки элементов в списке
%  (список, перестановка)
my_permute([], []).
my_permute(L, [X|T]) :- my_remove(X, L, Y), my_permute(Y, T).

%  Подсписки списка
%  (подсписок, список)
my_sublist(S, L) :- my_append(_, L1, L), my_append(S, _, L1).
```
`inclist_std(Zs, Poz, X, NewZs)` - вставка элемента X в список Zs на позицию Poz (на основе стандартных предикатов).
`inclist(Zs, Poz, X, NewZs)` - вставка элемента X в список Zs на позицию Poz (без использования стандартных предикатов).

Примеры использования:
```prolog
?- inclist_std([1, 2, 3, 5, 7, 9], 4, 9, X).
X = [1, 2, 3, 9, 5, 7, 9].

?- inclist_std([1, 2, 3, 5, 7, 9, 9], 7, 7, X).
X = [1, 2, 3, 5, 7, 9, 7, 9].

?- inclist([1, 2, 3], 2, 3, X).
X = [1, 2, 2, 3]. 

?- inclist([1, 1, 1, 1, 6, 5, 2, 3], 7, 5, X).
X = [1, 1, 1, 1, 7, 6, 5, 2, 3]. 
```

Реализация:
```prolog
inclist_std(Zs, Poz, X, Ps) :- Poz1 is Poz-1, length(Xs, Poz1), append(Xs, Ys, Zs), append(Xs, [X], Ls), append(Ls, Ys, Ps).
  
inclist(L,A,1,[A|L]).
inclist([L1|L0],A,N,R) :- Nn is N-1, inclist(L0,A,Nn,R0), R=[L1|R0].
```

Описание работы inclist_std: на вход подается исходный список, элемент, его позиция, выходной список. Список делится на две части. Если указанная позиция занята, то элемент исходного списка, занимающий эту позицию, сдвигается вправо, а новый элемент вставляется в список слева от него. В результате получается список с новым элементом.
Описание работы inclist: на вход подается то же самое, что и в предыдущем варианте. Отсекаем кусок, длиной равный позиции минус 1, списка с начала, в конец этого куска добавляем новый элемент и присоединяем отсеченную ранее вторую часть списка.

## Задание 1.2: Предикат обработки числового списка

`is_geometric_std(List)` - проверка списка List на геометрическую прогрессию (с помощью стандартных предикатов)
`is_geometric(List)` - проверка списка List на геометрическую прогрессию (без использования стандартных предикатов)

Примеры использования:
```prolog
?- is_geometric_std([1, 2, 3]).
false.

?- is_geometric_std([1, 3, 9]).
true.

?- is_geometric([1, 2, 3]).
false.

?- is_geometric([2, 4, 8]).
true.
```

Реализация:
```prolog
is_geometric_std([X, Y, Z|T]):- 
	!,
	(Y * Y) =:= (X * Z), 
	my_remove(X, [X, Y, Z|T], R), 
	is_geometric_std(R).
is_geometric_std(_).

is_geometric([X,Y,Z|T]):-
    !,
    X / Y =:= Y / Z,
    is_geometric([Y,Z|T]).
is_geometric(_).
```
Описание работы is_geometric_std: на вход подается список, из него выделяются первые три элемента, осуществляется проверка на геометрическую прогрессию, после чего каждый следующий элемент берется с помощью стандартного предиката remove.
Описание работы is_geometric: на вход подается список, где мы рекурсивно перебираем элементы, каждый раз проверяя текущие элементы, образуют ли они геометрическую прогрессию.

## Задание 1.3: пример совместного использования предикатов, реализованных в пунктах 1.1 и 1.2

`mixed(List, Elem, Poz)` - вставка элемента Elem на позицию Poz в списке List и проверка списка List на геометрическую прогрессию.

Примеры использования:
```prolog
?- mixed([1, 3, 9], 8, 2).
false.

?- mixed([1, 3, 9], 27, 4).
true.
```

Реализация:
```prolog
mixed(List, Elem, Poz) :- inclist(List, Elem, Poz, NewList), is_geometric(NewList).
```

Описание работы mixed: на вход подаются исходный список, элемент и его позиция. Далее происходит включение элемента в список, описанное в пункте 1.1, после чего новый список проверяется на геометрическую прогрессию методом, указанным в пункте 1.2.

## Задание 2: Реляционное представление данных

Преимущества реляционного представления: удобное представление данных, к которым можно обратиться без особых затруднений, независимость данных. Также основой модели является математический аппарат, строго описывающий операции, производимые над данными.
Недостатки реляционного представления: не все данные представимы в виде таблиц, требуются большие объемы памяти, если данные достаточно громоздкие. К тому же, при выполнении операции соединения все происходит достаточно медленно.

Преимущества представления в one.pl: независимость отдельных компонентов программы, удобно тестировать код.
Недостатки представления в one.pl: данные слишком раздроблены, и иногда запросы к ним получались достаточно, на мой взгляд, странными...

Предикаты, реализованные для работы с one.pl:
<ul>
  <li>`sum_grades(List, Sum)` - подсчет общей суммы оценок по предмету.</li>
  <li>`stud_lists(List)` - расчет среднего балла для каждого предмета.</li>
  <li>`average()` - выделение списка предметов, чтобы потом для каждого из предметов посчитать средний балл.</li>
  <li>`average(Subj, Mark)` - то же, что и выше, только позволяет задать конкретный предмет и посмотреть средний балл только по нему.</li>
  <li>`is_empty(List, Flag)` - проверка списка на пустоту.</li>
  <li>`has_bad_marks(List, Counter)` - выявление несдавших студентов.</li>
  <li>`find_bad_students(List)` - рассчет количества несдавших по каждой группе.</li>
  <li>`fallens()` - количество несдавших для каждой группы.</li>
  <li>`fallen_number(Group, Count)` - то же, что и выше, только позволяет задать конкретную группу, в которой нужно посмотреть число несдавших.</li>
  <li>`count_falls(List, Counter)` - подсчет количества двоек по предмету.</li>
  <li>`by_subject(List)` - подсчет несдавших по конкретному предмету.</li>
  <li>`fallen_by_all_subjects()` - подсчет несдавших по каждому предмету.</li>
  <li>`fallen_by_subject(Subj, X)` - то же, что и выше, только подсчет по одному конкретно указанному предмету.</li>
</ul>

## Задание 2.1: напечатать средний балл для каждого предмета

`average()` - средний балл для каждого предмета.
`average(Subj, Mark)` - средний балл Mark для предмета Subj.

Примеры использования:
```prolog
?- average().
LP: 3.9642857142857144
MTH: 3.6785714285714284
FP: 3.892857142857143
INF: 3.5714285714285716
ENG: 4.178571428571429
PSY: 3.607142857142857
true.

?- average('Логическое программирование', X).
LP:
X = 3.9642857142857144.
```

Реализация:
```prolog
%  подсчет общей суммы оценок по предмету
%  (список, сумма)
sum_grades([],0).
sum_grades([H|T], S) :-
	sum_grades(T, S1), 
	S = H + S1.	
	
%  рассчет среднего балла для каждого предмета
%  (список)
stud_lists([]).
stud_lists([H|T]) :- 
	findall(X, grade(_, H, X), MarksList),
	sum_grades(MarksList, Sum),
	length(MarksList, Len),
	Mark is Sum / Len,
	write(H),
	write(': '),
	write(Mark),
	write('\n'),
	stud_lists(T).	

%  выделение списка предметов и вызов основной функции	
average() :-
	findall(X, subject(X, _), Subs),
	stud_lists(Subs).
	
%  также, чтобы выводить средний балл по введенному вручную названию предмета,
%  можно воспользоваться следующим предикатом:
%  рассчет среднего балла по предмету
%  (предмет, средний балл)
average(Subj, Mark) :- 
	subject(EngSubj, Subj),
	findall(X, grade(_, EngSubj, X), MarksList),
	sum_grades(MarksList, Sum),
	length(MarksList, Len),
	Mark is Sum / Len,
	write(EngSubj),
	write(: ).
```

Описание работы average: если вызывается просто предикат, без указания предмета, то создается список предметов, далее для каждого предмета создаются списки оценок. Для каждого списка оценок происходит создание списка оценок, подсчет суммы оценок, длины списка оценок, потом рассчитывается средний балл. Если при вызове предиката указывается предмет, то лист оценок создается только для него, а далее происходит все то же самое.

## Задание 2.2: для каждой группы найти количество несдавших студентов

`fallens()` - количество несдавших по каждой группе.
`fallen_number(Group, Count)` - количество несдавших в конкретной группе.

Примеры использования:
```prolog
?- fallens().
102: 4
101: 2
104: 4
103: 3
true.

?- fallen_number(101, X).
X = 2.
```

Реализация:
```prolog
%  проверка на пустоту списка с двойками
%  (список, флаг (0 - нет пересдач, 1 - есть пересдача (или пересдачи))
is_empty([], 0).
is_empty([_|_], 1).

%  выявление несдавших студентов
%  (список студентов, количество студентов)
has_bad_marks([], 0).
has_bad_marks([H|T], C) :-
	findall(X, grade(H, X, 2), Peresdachi),
	is_empty(Peresdachi, N),
	has_bad_marks(T, C1), C = N + C1.

%  рассчет количества несдавших по каждой группе
%  (список групп)
find_bad_students([]).
find_bad_students([H|T]) :-
	findall(X, student(H, X), StL),
	has_bad_marks(StL, Num),
	Count is Num,
	write(H),
	write(': '),
	write(Count),
	write('\n'),
	find_bad_students(T).

%  количество несдавших для каждой группы
fallens() :-
	findall(X, student(X, _), Groups),
	list_to_set(Groups, Gr),
	find_bad_students(Gr).
	
%  также, чтобы выводить количество несдавших по введенному вручную номеру группы,
%  можно воспользоваться следующим предикатом:
%  количество несдавших в группе
%  (группа, количество студентов)
fallen_number(Group, Count) :-
	findall(X, student(Group, X), StL),
	has_bad_marks(StL, Num),
	Count is Num.
```

Описание работы fallens: создается список групп, исходя из списка студентов (ВОТ ОНО НЕУДОБСТВО ПРЕДСТАВЛЕНИЯ ONE.PL), далее исключаем повторения номеров групп, затем составляем по каждой группе список студентов, которых проверяем на наличие двоек. Есть хотя бы одна двойка = задолжник.
Описание работы fallen_numbers: составляем список студентов заданной группы... и далее то же самое, что описано у fallens.

## Задание 2.3: найти количество не сдавших студентов для каждого из предметов

`fallen_by_all_subjects()` - подсчет несдавших по каждому предмету.
`fallen_by_subject(Subj, X)` - подсчет несдавших по конкретному предмету.

Примеры использования:
```prolog
?- fallen_by_all_subjects().
LP: 3
MTH: 6
FP: 1
INF: 3
ENG: 1
PSY: 5
true.

?- fallen_by_subject('Логическое программирование', X).
X = 3.
```

Реализация:
```prolog
%  подсчет количества двоек по предмету
%  (список оценок, счетчик)
count_falls([],0).
count_falls([H|T],N):- H < 3, !, count_falls(T,M), N is M + 1.
count_falls([_|T],N):- count_falls(T,N).

%  подсчет несдавших по конкретному предмету
%  (список предметов)
by_subject([]).
by_subject([H|T]) :-
	findall(X, grade(_, H, X), Marks),
	count_falls(Marks, Num),
	write(H),
	write(': '),
	write(Num),
	write('\n'),
	by_subject(T).
	
%  подсчет несдавших по каждому предмету
fallen_by_all_subjects() :-
	findall(X, subject(X, _), Subs),
	by_subject(Subs).

%  также, чтобы выводить количество несдавших по введенному вручную названию предмета,
%  можно воспользоваться следующим предикатом:
%  количество несдавших по предмету
%  (предмет, число несдавших)
fallen_by_subject(Subj, X) :-
	subject(EngSubj, Subj),
	findall(X, grade(_, EngSubj, X), MarksList),
	count_falls(MarksList, X).
```

Описание работы fallen_by_all_subjects: создается список всех предметов, далее по каждому предмету создается отдельный список оценок, в котором происходит рассчет количества несдавших (по числу двоек).
Описание работы fallen_by_subject: то же самое, только опускается первый этап - создание списка всех предметов. Все остальное происходит в отношении одного конкретно указанного предмета.

## Выводы

Основная черта языка Пролог (и, в принципе, всех логических языков) в том, что он декларативен. В то время как императивные языки требуют описания последовательности действий, декларативные требуют описания того, что мы хотим от результата, причем больше, чем от процесса вычислений. В Прологе описывается то, что нужно получить, а компьютер решает, как получить этот результат.
На логических языках хорошо решаются задачи ИИ, обработки естественного языка, поиска решений, построения специализированных языков. Их особенностями являются отсутствие операторов присваивания, естественная математическая модель вычислений, возможности по представлению списков и деревьев.
В Прологе можно писать достаточно короткие программы, выполняющие довольно много действий.
Можно сказать, что после этой лабораторной я преисполнилась в своем познании.
